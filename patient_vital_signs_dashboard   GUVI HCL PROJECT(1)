# -*- coding: utf-8 -*-
"""Patient Vital Signs Dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EZsNcdcYPLxf_xHEt4m3UcCYvikmiLJg
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import datetime
from datetime import timedelta
import warnings
warnings.filterwarnings('ignore')

class VitalSignsAnalyzer:
    """
    A comprehensive class for analyzing patient vital signs data.

    This class handles data preprocessing, risk assessment, and provides
    methods for generating insights from patient vital signs.
    """

    def __init__(self):
        self.risk_thresholds = {
            'heart_rate': {'low': (60, 100), 'medium': (50, 120), 'high': (40, 140)},
            'systolic_bp': {'low': (90, 140), 'medium': (80, 160), 'high': (70, 180)},
            'diastolic_bp': {'low': (60, 90), 'medium': (50, 100), 'high': (40, 110)},
            'temperature': {'low': (97.0, 99.0), 'medium': (96.0, 100.0), 'high': (95.0, 101.0)},
            'oxygen_saturation': {'low': (95, 100), 'medium': (90, 100), 'high': (85, 100)}
        }

    def generate_sample_data(self, n_patients=50, days=30):
        """
        Generate realistic sample patient vital signs data.

        Args:
            n_patients (int): Number of patients to generate
            days (int): Number of days of data per patient

        Returns:
            pd.DataFrame: Generated vital signs data
        """
        np.random.seed(42)  # For reproducible results

        data = []
        patient_base_vitals = {}

        # Generate base vitals for each patient (individual variation)
        for patient_id in range(1, n_patients + 1):
            patient_base_vitals[patient_id] = {
                'heart_rate_base': np.random.normal(75, 10),
                'systolic_bp_base': np.random.normal(120, 15),
                'diastolic_bp_base': np.random.normal(80, 10),
                'temperature_base': np.random.normal(98.6, 0.5),
                'oxygen_saturation_base': np.random.normal(98, 1),
                'risk_factor': np.random.choice(['low', 'medium', 'high'], p=[0.6, 0.3, 0.1])
            }

        # Generate time series data
        start_date = datetime.datetime.now() - timedelta(days=days)

        for patient_id in range(1, n_patients + 1):
            base_vitals = patient_base_vitals[patient_id]

            for day in range(days):
                current_date = start_date + timedelta(days=day)

                # Generate multiple readings per day (every 4 hours)
                for hour in [0, 4, 8, 12, 16, 20]:
                    timestamp = current_date + timedelta(hours=hour)

                    # Add daily and circadian variations
                    circadian_factor = 1 + 0.1 * np.sin(2 * np.pi * hour / 24)
                    daily_variation = np.random.normal(0, 0.05)

                    # Risk factor influences (high-risk patients have more variation)
                    if base_vitals['risk_factor'] == 'high':
                        variation_multiplier = 2.0
                    elif base_vitals['risk_factor'] == 'medium':
                        variation_multiplier = 1.3
                    else:
                        variation_multiplier = 1.0

                    heart_rate = max(40, base_vitals['heart_rate_base'] * circadian_factor +
                                   np.random.normal(0, 5 * variation_multiplier) + daily_variation * 10)

                    systolic_bp = max(70, base_vitals['systolic_bp_base'] +
                                    np.random.normal(0, 8 * variation_multiplier) + daily_variation * 15)

                    diastolic_bp = max(40, base_vitals['diastolic_bp_base'] +
                                     np.random.normal(0, 5 * variation_multiplier) + daily_variation * 10)

                    temperature = base_vitals['temperature_base'] + np.random.normal(0, 0.3 * variation_multiplier)

                    oxygen_saturation = min(100, max(85, base_vitals['oxygen_saturation_base'] +
                                                   np.random.normal(0, 1 * variation_multiplier)))

                    data.append({
                        'patient_id': f'P{patient_id:03d}',
                        'timestamp': timestamp,
                        'heart_rate': round(heart_rate, 1),
                        'systolic_bp': round(systolic_bp, 1),
                        'diastolic_bp': round(diastolic_bp, 1),
                        'temperature': round(temperature, 1),
                        'oxygen_saturation': round(oxygen_saturation, 1),
                        'age': np.random.randint(25, 85),
                        'gender': np.random.choice(['M', 'F']),
                        'risk_category': base_vitals['risk_factor']
                    })

        df = pd.DataFrame(data)
        df = df.sort_values(['patient_id', 'timestamp']).reset_index(drop=True)

        return df

    def assess_risk_level(self, vital_value, vital_type):
        """
        Assess risk level for a specific vital sign value.

        Args:
            vital_value (float): The vital sign value
            vital_type (str): Type of vital sign

        Returns:
            str: Risk level ('normal', 'warning', 'critical')
        """
        thresholds = self.risk_thresholds.get(vital_type, {})

        if not thresholds:
            return 'normal'

        low_range = thresholds.get('low', (0, float('inf')))
        medium_range = thresholds.get('medium', (0, float('inf')))

        if low_range[0] <= vital_value <= low_range[1]:
            return 'normal'
        elif medium_range[0] <= vital_value <= medium_range[1]:
            return 'warning'
        else:
            return 'critical'

    def calculate_patient_risk_score(self, patient_data):
        """
        Calculate overall risk score for a patient based on latest vitals.

        Args:
            patient_data (pd.DataFrame): Patient's vital signs data

        Returns:
            dict: Risk assessment results
        """
        if patient_data.empty:
            return {'overall_risk': 'unknown', 'risk_score': 0, 'alerts': []}

        latest_data = patient_data.iloc[-1]
        risk_score = 0
        alerts = []

        # Check each vital sign
        vitals_to_check = ['heart_rate', 'systolic_bp', 'diastolic_bp', 'temperature', 'oxygen_saturation']

        for vital in vitals_to_check:
            if vital in latest_data:
                risk_level = self.assess_risk_level(latest_data[vital], vital)

                if risk_level == 'critical':
                    risk_score += 3
                    alerts.append(f"CRITICAL: {vital.replace('_', ' ').title()} = {latest_data[vital]}")
                elif risk_level == 'warning':
                    risk_score += 1
                    alerts.append(f"WARNING: {vital.replace('_', ' ').title()} = {latest_data[vital]}")

        # Determine overall risk category
        if risk_score >= 6:
            overall_risk = 'high'
        elif risk_score >= 3:
            overall_risk = 'medium'
        else:
            overall_risk = 'low'

        return {
            'overall_risk': overall_risk,
            'risk_score': risk_score,
            'alerts': alerts,
            'timestamp': latest_data['timestamp']
        }

class VitalSignsDashboard:
    """
    Jupyter-compatible dashboard for vital signs analysis.
    """

    def __init__(self):
        self.analyzer = VitalSignsAnalyzer()
        self.data = None

    def load_sample_data(self, n_patients=20, days=14):
        """Load sample data for analysis."""
        print("Generating sample patient data...")
        self.data = self.analyzer.generate_sample_data(n_patients, days)
        print(f"Generated data for {n_patients} patients over {days} days")
        print(f"Total records: {len(self.data)}")
        return self.data

    def load_csv_data(self, filepath):
        """Load data from CSV file."""
        try:
            self.data = pd.read_csv(filepath)
            self.data['timestamp'] = pd.to_datetime(self.data['timestamp'])
            print(f"Loaded {len(self.data)} records from {filepath}")
            return self.data
        except Exception as e:
            print(f"Error loading file: {str(e)}")
            return None

    def show_data_overview(self):
        """Display data overview and quality metrics."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        print("=== DATA OVERVIEW ===")
        print(f"Total Records: {len(self.data)}")
        print(f"Unique Patients: {self.data['patient_id'].nunique()}")
        print(f"Date Range: {self.data['timestamp'].min()} to {self.data['timestamp'].max()}")
        print(f"Days Covered: {(self.data['timestamp'].max() - self.data['timestamp'].min()).days}")
        print(f"Missing Values: {self.data.isnull().sum().sum()}")

        print("\n=== VITAL SIGNS SUMMARY ===")
        vital_cols = ['heart_rate', 'systolic_bp', 'diastolic_bp', 'temperature', 'oxygen_saturation']
        summary = self.data[vital_cols].describe()
        print(summary.round(2))

        print("\n=== RISK DISTRIBUTION ===")
        risk_dist = self.data['risk_category'].value_counts()
        for risk, count in risk_dist.items():
            percentage = (count / len(self.data)) * 100
            print(f"{risk.upper()}: {count} ({percentage:.1f}%)")

    def plot_heart_rate_trends(self, patient_ids=None, days_back=7):
        """Plot heart rate trends for selected patients."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        # Filter data
        if patient_ids is None:
            patient_ids = sorted(self.data['patient_id'].unique())[:5]

        cutoff_date = self.data['timestamp'].max() - timedelta(days=days_back)
        filtered_data = self.data[
            (self.data['patient_id'].isin(patient_ids)) &
            (self.data['timestamp'] >= cutoff_date)
        ]

        # Create plot
        fig = px.line(
            filtered_data,
            x='timestamp',
            y='heart_rate',
            color='patient_id',
            title=f"Heart Rate Trends - Last {days_back} Days",
            labels={'heart_rate': 'Heart Rate (BPM)', 'timestamp': 'Time'}
        )

        # Add normal range indicators
        fig.add_hline(y=60, line_dash="dash", line_color="green", annotation_text="Lower Normal (60)")
        fig.add_hline(y=100, line_dash="dash", line_color="green", annotation_text="Upper Normal (100)")
        fig.add_hrect(y0=60, y1=100, fillcolor="green", opacity=0.1)

        fig.update_layout(height=500)
        fig.show()

    def plot_vital_signs_distribution(self):
        """Plot distribution of all vital signs."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        fig = make_subplots(
            rows=2, cols=3,
            subplot_titles=('Heart Rate', 'Systolic BP', 'Diastolic BP',
                          'Temperature', 'Oxygen Saturation', 'Risk Distribution'),
            specs=[[{"secondary_y": False}, {"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}, {"secondary_y": False}]]
        )

        # Heart Rate
        fig.add_trace(
            go.Histogram(x=self.data['heart_rate'], name='Heart Rate', nbinsx=30),
            row=1, col=1
        )

        # Systolic BP
        fig.add_trace(
            go.Histogram(x=self.data['systolic_bp'], name='Systolic BP', nbinsx=30),
            row=1, col=2
        )

        # Diastolic BP
        fig.add_trace(
            go.Histogram(x=self.data['diastolic_bp'], name='Diastolic BP', nbinsx=30),
            row=1, col=3
        )

        # Temperature
        fig.add_trace(
            go.Histogram(x=self.data['temperature'], name='Temperature', nbinsx=30),
            row=2, col=1
        )

        # Oxygen Saturation
        fig.add_trace(
            go.Histogram(x=self.data['oxygen_saturation'], name='O2 Sat', nbinsx=30),
            row=2, col=2
        )

        # Risk Distribution
        risk_counts = self.data['risk_category'].value_counts()
        fig.add_trace(
            go.Bar(x=risk_counts.index, y=risk_counts.values, name='Risk Distribution'),
            row=2, col=3
        )

        fig.update_layout(height=600, title_text="Vital Signs Distribution", showlegend=False)
        fig.show()

    def plot_patient_comparison(self, patient_ids=None, vital_sign='heart_rate'):
        """Compare a specific vital sign across patients."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        if patient_ids is None:
            patient_ids = sorted(self.data['patient_id'].unique())[:10]

        filtered_data = self.data[self.data['patient_id'].isin(patient_ids)]

        fig = px.box(
            filtered_data,
            x='patient_id',
            y=vital_sign,
            color='risk_category',
            title=f"{vital_sign.replace('_', ' ').title()} Distribution by Patient",
            color_discrete_map={'low': '#4CAF50', 'medium': '#FF9800', 'high': '#F44336'}
        )

        fig.update_xaxes(tickangle=45)
        fig.update_layout(height=500)
        fig.show()

    def generate_risk_assessment(self, patient_ids=None):
        """Generate risk assessment for selected patients."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        if patient_ids is None:
            patient_ids = sorted(self.data['patient_id'].unique())[:10]

        print("=== PATIENT RISK ASSESSMENT ===")

        risk_assessments = []
        for patient_id in patient_ids:
            patient_data = self.data[self.data['patient_id'] == patient_id]
            risk_info = self.analyzer.calculate_patient_risk_score(patient_data)

            print(f"\nPatient: {patient_id}")
            print(f"Overall Risk: {risk_info['overall_risk'].upper()}")
            print(f"Risk Score: {risk_info['risk_score']}")
            print(f"Last Assessment: {risk_info['timestamp']}")

            if risk_info['alerts']:
                print("Active Alerts:")
                for alert in risk_info['alerts']:
                    print(f"  • {alert}")
            else:
                print("No active alerts")

            risk_assessments.append({
                'Patient': patient_id,
                'Risk Level': risk_info['overall_risk'],
                'Risk Score': risk_info['risk_score'],
                'Alert Count': len(risk_info['alerts'])
            })

        # Create summary DataFrame
        risk_df = pd.DataFrame(risk_assessments)
        print(f"\n=== RISK SUMMARY ===")
        print(risk_df.to_string(index=False))

        return risk_df

    def plot_correlation_matrix(self):
        """Plot correlation matrix of vital signs."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        vital_columns = ['heart_rate', 'systolic_bp', 'diastolic_bp', 'temperature', 'oxygen_saturation']
        correlation_matrix = self.data[vital_columns].corr()

        fig = px.imshow(
            correlation_matrix,
            title="Vital Signs Correlation Matrix",
            color_continuous_scale='RdBu_r',
            aspect='auto',
            text_auto=True
        )

        fig.update_layout(height=500)
        fig.show()

    def export_data(self, filename='patient_vitals_export.csv', include_risk_assessment=True):
        """Export data with optional risk assessments."""
        if self.data is None:
            print("No data loaded. Please load data first.")
            return

        export_data = self.data.copy()

        if include_risk_assessment:
            print("Adding risk assessments to export...")
            risk_levels = []

            for _, row in export_data.iterrows():
                hr_risk = self.analyzer.assess_risk_level(row['heart_rate'], 'heart_rate')
                bp_risk = self.analyzer.assess_risk_level(row['systolic_bp'], 'systolic_bp')
                temp_risk = self.analyzer.assess_risk_level(row['temperature'], 'temperature')
                o2_risk = self.analyzer.assess_risk_level(row['oxygen_saturation'], 'oxygen_saturation')

                risk_levels.append({
                    'hr_risk_level': hr_risk,
                    'bp_risk_level': bp_risk,
                    'temp_risk_level': temp_risk,
                    'o2_risk_level': o2_risk
                })

            risk_df = pd.DataFrame(risk_levels)
            export_data = pd.concat([export_data, risk_df], axis=1)

        export_data.to_csv(filename, index=False)
        print(f"Data exported to {filename}")
        print(f"Records exported: {len(export_data)}")

# Usage Example
def demo_dashboard():
    """Demonstrate dashboard functionality."""
    print("🏥 PATIENT VITAL SIGNS DASHBOARD - JUPYTER VERSION")
    print("=" * 60)

    # Initialize dashboard
    dashboard = VitalSignsDashboard()

    # Load sample data
    dashboard.load_sample_data(n_patients=15, days=14)

    # Show data overview
    dashboard.show_data_overview()

    # Display visualizations
    print("\n📈 Generating Heart Rate Trends...")
    dashboard.plot_heart_rate_trends(days_back=7)

    print("\n📊 Generating Vital Signs Distribution...")
    dashboard.plot_vital_signs_distribution()

    print("\n👥 Generating Patient Comparison...")
    dashboard.plot_patient_comparison(vital_sign='heart_rate')

    print("\n🔍 Generating Correlation Analysis...")
    dashboard.plot_correlation_matrix()

    print("\n⚠️ Performing Risk Assessment...")
    risk_summary = dashboard.generate_risk_assessment()

    return dashboard

# Run the demo
if __name__ == "__main__":
    # Create and run the dashboard
    dash = demo_dashboard()

    print("\n" + "="*60)
    print("Dashboard loaded successfully!")
    print("\nAvailable methods:")
    print("- dash.plot_heart_rate_trends(patient_ids=['P001', 'P002'], days_back=7)")
    print("- dash.plot_patient_comparison(vital_sign='systolic_bp')")
    print("- dash.generate_risk_assessment(patient_ids=['P001', 'P002'])")
    print("- dash.export_data('my_export.csv')")
    print("\nUse dash.data to access the DataFrame directly")